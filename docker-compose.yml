# Ce fichier configure tous les services qui composent l'application e-commerce
# Docker Compose permet de gérer plusieurs conteneurs comme un seul système
# Chaque service (base de données, API, interface web) fonctionne dans son propre conteneur

version: '3.8'  # Version du format Docker Compose utilisé

services:
  # =====================================================================
  # RABBITMQ - Système de messagerie entre les services
  # =====================================================================
  rabbitmq:
    image: rabbitmq:3-management                    # Image RabbitMQ avec interface d'administration
    container_name: rabbitmq-shared                 # Nom du conteneur
    environment:
      RABBITMQ_DEFAULT_USER: guest                  # Nom d'utilisateur par défaut
      RABBITMQ_DEFAULT_PASS: guest                  # Mot de passe par défaut
    ports:
      - "5672:5672"                                 # Port pour les connexions des applications
      - "15672:15672"                               # Port pour l'interface web d'administration
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq             # Stockage persistant des messages
    networks:
      - microservices-network                       # Réseau partagé entre tous les services
    healthcheck:                                    # Vérification que le service fonctionne
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 30s                                 # Vérifier toutes les 30 secondes
      timeout: 10s                                  # Timeout de 10 secondes
      retries: 5                                    # 5 tentatives avant de considérer le service en panne

  # =====================================================================
  # BASES DE DONNÉES PostgreSQL - Une pour chaque service
  # =====================================================================
  
  # Base de données pour le service des clients
  clients-db:
    image: postgres:15                              # Version PostgreSQL 15
    container_name: clients-db                      # Nom du conteneur
    environment:
      POSTGRES_USER: postgres                       # Nom d'utilisateur de la base
      POSTGRES_PASSWORD: root                       # Mot de passe de la base
      POSTGRES_DB: clientsdb                        # Nom de la base de données
      POSTGRES_PORT: 5432                           # Port PostgreSQL standard
    ports:
      - "5432:5432"                                 # Port exposé vers l'extérieur
    volumes:
      - clients_postgres_data:/var/lib/postgresql/data                    # Stockage persistant des données
      - ./API_Clients/customers.sql:/docker-entrypoint-initdb.d/01-init.sql # Script d'initialisation
    networks:
      - microservices-network
    healthcheck:                                    # Vérification de l'état de la base
      test: ["CMD-SHELL", "pg_isready -U postgres -d clientsdb"]
      interval: 5s
      timeout: 10s
      retries: 5

  # PostgreSQL for API_Commandes
  commandes-db:
    image: postgres:15
    container_name: commandes-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: root
      POSTGRES_DB: api_commandes
    ports:
      - "5431:5432"
    volumes:
      - commandes_postgres_data:/var/lib/postgresql/data
      - ./API_Commandes/orders.sql:/docker-entrypoint-initdb.d/01-init.sql
    networks:
      - microservices-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d api_commandes"]
      interval: 5s
      timeout: 10s
      retries: 5

  # PostgreSQL for API_Produits
  produits-db:
    image: postgres:15
    container_name: produits-db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: root
      POSTGRES_DB: api_produits
    ports:
      - "5433:5432"
    volumes:
      - produits_postgres_data:/var/lib/postgresql/data
      - ./API_Produits/products.sql:/docker-entrypoint-initdb.d/01-init.sql
    networks:
      - microservices-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d api_produits"]
      interval: 5s
      timeout: 10s
      retries: 5

  # API Clients Service
  api-clients:
    build:
      context: ./API_Clients
      dockerfile: Dockerfile
    container_name: client-api
    ports:
      - "8002:8002"
    depends_on:
      clients-db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    environment:
      APP_ENV: "prod"
      DATABASE_URL: "postgresql://postgres:root@clients-db:5432/clientsdb"
      RABBITMQ_HOST: "rabbitmq-shared"
      RABBITMQ_PORT: "5672"
      RABBITMQ_USER: "guest"
      RABBITMQ_PASSWORD: "guest"
      QUEUE_NAME: "client_events"
    networks:
      - microservices-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8002/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
    volumes:
      - ./API_Clients:/app

  # API Commandes Service
  api-commandes:
    build:
      context: ./API_Commandes
      dockerfile: Dockerfile
    container_name: commande-api
    ports:
      - "8000:8000"
    depends_on:
      commandes-db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    environment:
      APP_ENV: "prod"
      DATABASE_URL: "postgresql://postgres:root@commandes-db:5432/api_commandes"
      RABBITMQ_HOST: "rabbitmq-shared"
      RABBITMQ_PORT: "5672"
      RABBITMQ_USER: "guest"
      RABBITMQ_PASSWORD: "guest"
      PYTHONPATH: "/app"
      PRODUCTS_SERVICE_URL: "http://produit-api:8001"
      CLIENTS_SERVICE_URL: "http://client-api:8002"
    networks:
      - microservices-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
    volumes:
      - ./API_Commandes:/app

  # API Produits Service
  api-produits:
    build:
      context: ./API_Produits
      dockerfile: Dockerfile
    container_name: produit-api
    ports:
      - "8001:8001"
    depends_on:
      produits-db:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    environment:
      APP_ENV: "prod"
      DATABASE_URL: "postgresql://postgres:root@produits-db:5432/api_produits"
      RABBITMQ_HOST: "rabbitmq-shared"
      RABBITMQ_PORT: "5672"
      RABBITMQ_USER: "guest"
      RABBITMQ_PASSWORD: "guest"
    networks:
      - microservices-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8001/docs"]
      interval: 30s
      timeout: 10s
      retries: 3
    volumes:
      - ./API_Produits:/app


  # Frontend Service
  frontend:
    build:
      context: ./API_Clients/frontend
      dockerfile: Dockerfile.frontend
    container_name: frontend
    ports:
      - "80:80"
    networks:
      - microservices-network
    depends_on:
      - api-clients

  # Orders Frontend Service
  orders-frontend:
    build:
      context: ./API_Commandes/frontend
      dockerfile: Dockerfile.orders
    container_name: orders-frontend
    networks:
      - microservices-network
    depends_on:
      - api-commandes

  # pgAdmin for Database Management
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@pgadmin.com
      PGADMIN_DEFAULT_PASSWORD: admin
      PGADMIN_CONFIG_SERVER_MODE: "False"
    ports:
      - "5050:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
      - ./pgadmin/servers.json:/pgadmin4/servers.json
      - ./pgadmin/pgpassfile:/tmp/pgpassfile
    networks:
      - microservices-network
    depends_on:
      - clients-db
      - commandes-db
      - produits-db

  # Reverse Proxy Caddy
  caddy:
    image: caddy:2-alpine
    container_name: caddy
    ports:
      - "8085:80"
    volumes:
      - ./API_Clients/Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
      - caddy_config:/config
    networks:
      - microservices-network
    depends_on:
      - api-clients
      - api-commandes
      - api-produits
      - orders-frontend

networks:
  microservices-network:
    driver: bridge

volumes:
  rabbitmq_data:
  clients_postgres_data:
  commandes_postgres_data:
  produits_postgres_data:
  pgadmin_data:
  caddy_data:
  caddy_config: